const cds = require('../cds');
const crypto = require('crypto');
const Logger = require("./logger");
const { support, ERRORS } = require('../errors/supportability');
const { SCOPES } = require('../../config/constants');

class SecurityHelper {

    static get logger() {
        return this._logger = this._logger || Logger('SECURITY_HELPER');
    }

    static getXsappname() {
        const authCredentials = this.getAuthCredentials();
        if (!authCredentials) {
            throw new Error(`No auth credentials found`);
        }
        const { xsappname } = authCredentials;
        if (!xsappname) {
            throw new Error(`Failed to get 'xsappname' from auth credentials`);
        }
        return xsappname;
    }

    static insertXsappname(xsappname, scopes) {
        return scopes.map(scope => scope.replace('$XSAPPNAME', xsappname));
    }

    static getAllRequiredScopes(includeOptional = true) {
        const xsappname = this.getXsappname();
        return Object.entries(this.CLIENT_OPERATION_SCOPES_OPTIONAL)
            .filter(([, optional]) => includeOptional || !optional)
            .reduce((result, [kind]) => result.concat(this.insertXsappname(
                xsappname,
                kind in this.CONFIGURABLE_SCOPE_KEYS
                    ? this.getConfiguredScopes(kind)
                    : [SCOPES[kind]]
                )), []);
    }

    static getAllRequiredScopesForRequest(includeOptional = true) {
        return encodeURIComponent(this.getAllRequiredScopes(includeOptional).join(' '));
    }

    static get CONFIGURABLE_SCOPE_KEYS() {
        return {
            SUBSCRIPTION: 'subscription-scope',
            DEPLOYMENT:   'deployment-scope'
        };
    }

    static get CLIENT_OPERATION_SCOPES_OPTIONAL() {
        return {
            EXTEND: false,
            DELETE: true
        };
    }

    static get DEFAULT_SCOPES() {
        // this could be done as cds env default
        return {
            SUBSCRIPTION: [SCOPES.SUBSCRIPTION],
            DEPLOYMENT:   [SCOPES.DEPLOYMENT]
        };
    }

    static getConfiguredScopes(scopeKind) {
        const scopeKey = this.CONFIGURABLE_SCOPE_KEYS[scopeKind];
        const scopeConfig = cds.env.mtx && cds.env.mtx.security && cds.env.mtx.security[scopeKey];
        if (scopeConfig) {
            let configuredScopes = Array.isArray(scopeConfig) ? scopeConfig : [scopeConfig];
            configuredScopes = configuredScopes.filter(scope => scope.trim().length);
            if (configuredScopes.length) {
                return configuredScopes;
            }
        }
        return this.DEFAULT_SCOPES[scopeKind];
    }

    static checkScope(context, scope) {
        const authInfo = this._getAuthInfo(context);

        if (authInfo && authInfo.checkScope(scope) /* cds 3 */ || context.user && context.user.is(scope) /* cds 4 */) {
            this.logger.debug(`User has the relevant scope: ${scope}`);
            return true;
        }

        this.logger.error(`User doesn't have the relevant scope: ${scope}`);
        return false;
    }

    static _getAuthInfo(context) {
        return context._ && context._.req && context._.req.authInfo;
    }

    static getSubdomain(context) {
        const authInfo = this._getAuthInfo(context);
        return authInfo && authInfo.getSubdomain() || context.user.subdomain;
    }

    static getTenant(context) {
        const authInfo = this._getAuthInfo(context);
        return authInfo && authInfo.identityZone || context.tenant || context.user && context.user.tenant;
    }

    static async checkAuthorization(context, parameterTenantId = null) {
        const authenticatedTenantId = this.getTenant(context);
        const requestedTenantId = parameterTenantId || authenticatedTenantId;
        this.logger.debug(`Checking authorization for parameterId: ${parameterTenantId}; requestedId: ${requestedTenantId}; authenticatedId: ${authenticatedTenantId}`);

        if (!this.requestAllowed(requestedTenantId, authenticatedTenantId)) {
            const error = new Error('Unauthorized');
            error.code = error.statusCode = 401;
            throw error;
        }

        return requestedTenantId;
    }

    static requestAllowed(requestedTenantId, authenticatedTenantId, suppressErrors = false) {
        const identityzoneid = this.getIdentityZone();
        const allowed = !!authenticatedTenantId && [requestedTenantId, identityzoneid].includes(authenticatedTenantId);
        if (!suppressErrors && !allowed) {
            this.logger.error(`The request is not allowed as the XSUAA credentials' 'identityzoneid' doesn't match the authenticated tenant ID.`);
        }
        return allowed;
    }

    static getIdentityZone() {
        return (SecurityHelper.getAuthCredentials('multitenancy') || {}).identityzoneid;
    }

    static getAuthCredentials(...moreServiceAlternatives) {
        return SecurityHelper.getCredentials('auth', 'uaa', ...moreServiceAlternatives);
    }

    static getCredentials(...serviceAlternatives) {
        const errors = [];

        for (const service of serviceAlternatives) {
            const serviceKinds = new Map([['auth', 'xsuaa'], ['multitenancy', 'saas-registry'], ['uaa', 'xsuaa']]);

            const serviceCredentials = cds.env.get(`requires.${service}.credentials`);
            const serviceKind = cds.env.get(`requires.${service}.kind`);

            if (!serviceCredentials) {
                errors.push(() => support(ERRORS.bindingMissing(service), this.logger, 'warn'));
                continue;
            }

            if (serviceKind != serviceKinds.get(service)) {
                errors.push(() => support(ERRORS.bindingNotKind(service, serviceKinds.get(service)), this.logger, 'warn'));
                continue;
            }

            return serviceCredentials;
        }

        errors.forEach(e => e());
        return null;
    }

    static hash(seed) {
        const md5sum = crypto.createHash('md5');
        return md5sum.update(seed).digest('hex');
    }
}

module.exports = SecurityHelper;
