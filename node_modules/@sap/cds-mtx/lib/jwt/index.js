const https = require('https');
const { URL } = require('url');
const SecurityHelper = require('../helper/security_helper');
const HttpHelper = require('../helper/http_helper');
const Logger = require('../helper/logger');
const { support, ERRORS } = require('../errors/supportability');

class Jwt {

    static get logger() {
        return this._logger = this._logger || Logger('JWT');
    }

    static async requestJwtToken(request, includeOptionalScopes = true) {

        const passcode = request.query['passcode'];
        const refreshToken = request.query['refresh_token'];
        const subdomain = request.query['subdomain'];
        const clientid = request.query['clientid'];
        const clientsecret = request.query['clientsecret'];

        return new Promise((resolve, reject) => {
            try {
                var requestOptions = this._createRequestOptions({
                    passcode,
                    refreshToken,
                    subdomain,
                    clientid,
                    clientsecret
                }, includeOptionalScopes);
            } catch (error) {
                return reject(error);
            }

            Jwt.logger.debug(`Requesting token from ${requestOptions.host}`);

            let result = '';
            const req = https.request(requestOptions, res => {
                res.on('data', data => {
                    result += data;
                });
                res.on('end', () => {
                    let responseString = result.toString('utf-8');
                    try {
                        const response = JSON.parse(responseString);
                        if (response.error) {
                            if (response.error === 'invalid_scope' && includeOptionalScopes) {
                                support(ERRORS.jwtOptionalScopesMissing, Jwt.logger, 'debug');
                                return resolve(Jwt.requestJwtToken(request, false));
                            }
                            response.passcode_url = `https://${requestOptions.host}/passcode`;
                            const throwable = support(ERRORS.jwtRequestFailed(null, response), Jwt.logger, 'error');
                            return reject(throwable);
                        }
                        if (!response.access_token) {
                            const throwable = support(ERRORS.jwtIncompleteResponse(response), Jwt.logger, 'error');
                            return reject(throwable);
                        }
                        response.passcode_url = `https://${requestOptions.host}/passcode`;
                        return resolve(JSON.stringify(response));
                    } catch (error) {
                        const throwable = support(ERRORS.jwtMalformedResponse(responseString), Jwt.logger, 'error');
                        return reject(throwable);
                    }
                });
            });
            req.on('error', (error) => {
                const throwable = support(ERRORS.jwtRequestFailed(error), Jwt.logger, 'error');
                return reject(throwable);
            });
            req.end();
        });
    }

    static _createRequestOptions({ passcode, refreshToken, subdomain, clientid, clientsecret }, includeOptionalScopes = true) {

        const credentials = SecurityHelper.getAuthCredentials();
        if (!credentials) {
            throw new Error('No auth credentials defined');
        }

        const uaaUrl = credentials.url;
        const parsedUrl = new URL(uaaUrl);

        const hostname = parsedUrl.hostname.split('.');
        hostname[0] = subdomain;
        parsedUrl.hostname = hostname.join('.');

        Jwt.logger.info(`Get auth token using URL ${parsedUrl}`);

        if (clientid) {
            Jwt.logger.info(`Using clientid/clientsecret from API call. clientid: ${clientid}`);
        }

        // only check clientid: if set use both clientid and clientsecret from options
        const usedClientid = clientid ? clientid : credentials.clientid;
        const usedClientsecret = clientid ? clientsecret : credentials.clientsecret;
        const path = (refreshToken
                ? `/oauth/token?grant_type=refresh_token&refresh_token=${refreshToken}`
                : `/oauth/token?grant_type=password${passcode ? `&passcode=${passcode}` : ''}`
        ) + '&scope=' + SecurityHelper.getAllRequiredScopesForRequest(includeOptionalScopes);

        return {
            host: parsedUrl.hostname,
            path,
            method: 'POST',
            auth: `${usedClientid}:${usedClientsecret}`,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Accept': 'application/json'
            }
        };
    }

    static async getSaasRegistryToken(url, clientid, clientsecret) {
        const authString = `${clientid}:${clientsecret}`;
        Jwt.logger.info(`Getting saas-registry auth token from ${url}`);
        return HttpHelper.sendJsonRequest('POST', `${url}/oauth/token?grant_type=client_credentials&response_type=token`, authString, {});
    }

}

module.exports = Jwt;
