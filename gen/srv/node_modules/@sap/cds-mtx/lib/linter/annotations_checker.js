const Checker = require('./checker_base');

const AT_REQUIRES = '@requires';
const AT_RESTRICT = '@restrict';
const AT_CDS_PERSISTENCE_JOURNAL = '@cds.persistence.journal';
const AT_SQL_APPEND = '@sql.append';
const AT_SQL_PREPEND = '@sql.prepend';

const checkedAnnotations = new Map(
    [
        [ AT_REQUIRES , _createSecurityAnnotationWarning ],
        [ AT_RESTRICT , _createSecurityAnnotationWarning],
        [ AT_CDS_PERSISTENCE_JOURNAL , _createJournalAnnotationWarning],
        [ AT_SQL_APPEND , _createSqlAnnotationWarning],
        [ AT_SQL_PREPEND , _createSqlAnnotationWarning],
    ]
);

function _createSqlAnnotationWarning(annotationName, originFile, annotation) {
    return `Annotation ${annotationName} is not supported in extensions: ${originFile}`
        + `(line: ${annotation.$location.line}, col: ${annotation.$location.col})`;
}

function _createSecurityAnnotationWarning(annotationName, originFile, annotation) {
    return `Security relevant annotation ${annotationName} cannot be overwritten: ${originFile}`
        + `(line: ${annotation.$location.line}, col: ${annotation.$location.col})`;
}

function _createJournalAnnotationWarning(journalAnnotationName, originFile, annotation) {
    return `Enabling schema evolution in extensions using ${journalAnnotationName} not yet supported: ${originFile}`
        + ` (line: ${annotation.$location.line}, col: ${annotation.$location.col})`;
}

class AnnotationsChecker extends Checker {

    static async check(reflectedCsn, extensionFiles, compileDir) {

        if (!reflectedCsn.extensions) {
            return [];
        }

        // annotations via annotate - applies for all
        const annotationExtensions = Object.values(reflectedCsn.extensions)
            .filter( value => (value.annotate && Object.getOwnPropertyNames(value).filter( property => checkedAnnotations.get(property))));

        // check annotations for extensions including fields
        reflectedCsn.forall(()=>true, (element) => {
            if (element[AT_SQL_PREPEND] || element[AT_SQL_APPEND]) {
                if (!element.annotate) { // do not add annotation extensions again
                    annotationExtensions.push(element);
                }
            }
        }, reflectedCsn.extensions);

        // check entities and fields from definitions
        const annotatedDefinitions = [];
        reflectedCsn.forall(()=>true, (element) => {
            if (element[AT_SQL_PREPEND] || element[AT_SQL_APPEND] || element[AT_CDS_PERSISTENCE_JOURNAL]) {
                annotatedDefinitions.push(element);
            }
        }, reflectedCsn.definitions);

        const warnings = [];

        for (const annotationExtension of annotationExtensions) {
            const warning = this._checkAnnotation(annotationExtension, reflectedCsn.definitions, compileDir);
            if (warning) {
                warnings.push(warning);
            }
        }

        for (const annotatedDefinition of annotatedDefinitions) {
            const warning = this._checkAnnotation(annotatedDefinition, reflectedCsn.definitions, compileDir);
            if (warning) {
                warnings.push(warning);
            }
        }

        return warnings;
    }


    static _checkAnnotation(annotation, definitions, compileDir) {

        if (!definitions[annotation.annotate]) {
            return this._createAnnotationsWarning(annotation, compileDir);
        }

        return null;
    }

    static _createAnnotationsWarning(annotation, compileDir) {

        const annotationName = Object.getOwnPropertyNames(annotation).filter( property => checkedAnnotations.get(property));

        const originFile = this._localizeFile(annotation.$location.file, compileDir);

        if (annotationName.length) {
            return checkedAnnotations.get(annotationName[0])(annotationName, originFile, annotation);
        }
    }

}

module.exports = AnnotationsChecker;